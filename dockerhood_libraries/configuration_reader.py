# This file is part of Dockerhood.
#
# Dockerhood is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Dockerhood is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with Dockerhood. If not, see <http://www.gnu.org/licenses/>.
#

from docker import APIClient as Client
from docker.tls import TLSConfig
from configparser import ConfigParser
from os import path
import re
import warnings

from dockerhood_libraries.exceptions import InvalidIP, InvalidNetworkIP,\
    IpConflict, InvalidPort, InvalidProjectName

__author__ = 'Stefano Piani <stefano.piani@exact-lab.it>'
__copyright__ = "Copyright 2016, eXact-lab"

# This it the regular express that the project name must match to be accepted
PROJECT_NAME_MASK = r'^[a-z][a-z0-9-]*$'


class IP(object):
    """
    An object that represent a valid IPv4 number

    Args:
        - ip_string (str): the ip as a text string
    """
    def __init__(self, ip_string):
        ip_splitted = ip_string.strip().split('.')
        if len(ip_splitted) != 4:
            raise InvalidIP('{} does not represent a valid IPv4 (too few or '
                            'too many dots)'.format(ip_string))

        ip_split_numbers = []
        for k in ip_splitted:
            try:
                k_int = int(k)
            except ValueError:
                raise InvalidIP('{} in the ip {} is not a non negative integer'
                                ' smaller than 256'.format(k, ip_string))
            if k_int < 0 or k_int > 255:
                raise InvalidIP('{} in the ip {} is not a non negative integer'
                                ' smaller than 256'.format(k, ip_string))
            ip_split_numbers.append(k_int)

        self.int_value = 0
        for k in ip_split_numbers:
            self.int_value = self.int_value*256 + k

    def __str__(self):
        output = ''
        t = self.int_value
        for i in range(4):
            output = '.' + str(t % 256) + output
            t //= 256
        return output[1:]

    def __repr__(self):
        return "IP('" + self.__str__() + "')"

    def __eq__(self, other):
        return self.as_integer() == other.as_integer()

    def as_string(self):
        return self.__str__()

    def as_integer(self):
        return self.int_value


class ClassCNetworkIP(IP):
    """
    A particular IP that represent a class C network

    Args:
        - ip_string (str): the ip as a text string
    """
    def __init__(self, ip_string):
        super(ClassCNetworkIP, self).__init__(ip_string)
        if self.int_value % 256 != 0:
            raise InvalidNetworkIP('"{}" is expected to be a string that '
                                   'represent a Class C network and, '
                                   'therefore, its last number must be a 0'
                                   ''.format(ip_string))

    def __repr__(self):
        return "ClassCNetworkIP('" + self.__str__() + "')"


class StaticService(object):
    """
    A Static Service is a particular container that, when it is executed,
    uses the static network

    Args:
        - name (str): the name of the service
        - ip (str): the ip on the static network vpn
        - system_template (str): the first part of the Dockerfile that will be
          used to build the image
        - user_template (str): the last part of the Dockerfile, written by the
          user (if it is None, just the system_template will be used)
        - user_defined (boolean): This is False if this static service is a
          service build by the system without any request by the user. The
          services that are not user_defined are
    """

    def __init__(self, name, ip, system_template, user_template=None,
                 user_defined=True):
        self.name = name.lower()
        self.ip = IP(ip)
        self.system_template = system_template
        self.user_template = user_template
        self.user_defined = user_defined

    def __str__(self):
        return self.name

    def __repr__(self):
        return "StaticService({}, {}, '{}', {}, user_defined={})".format(
            self.name,
            self.ip.as_string(),
            self.system_template,
            self.user_template,
            self.user_defined
        )


class Network(object):
    """
    An object that describes an openvpn network generated by the linker docker

    Args:
        - name (str): the name of the network
        - network (str): the subnet of the network (like '192.168.0.0'). It is
          assumed that the netmask is 255.255.255.0
        - port (int): the port where the openvpn server will listen for client
          connections
    """
    def __init__(self, name, network, port):
        self.name = name
        self.network_ip = ClassCNetworkIP(network)
        self.port = int(port)

        if self.port < 1 or self.port > 65535:
            raise InvalidPort('Specified {} as port number, but a port number '
                              'must be a positive integer smaller than 65535 '
                              '(usually, a number between 1024 and 49151)'
                              ''.format(self.port))
        if self.port < 1024:
            warnings.warn('Using port {}! Use a port between 1 and 1023 '
                          'requires special privileges and is not recommended! '
                          'If you do not have a really good reason to use this '
                          'port, please change your configuration file'
                          ''.format(self.port))

        self.server_address = IP('.'.join(network.split('.')[:3]) + '.1')

    def __contains__(self, ip_object):
        """
        Check if a particular Ip is inside the network

        Args:
            - ip_object: an IP object

        Returns
            True if the IP is inside the network, False otherwise
        """
        diff = ip_object.as_integer() - self.network_ip.as_integer()
        if 0 < diff < 255:
            return True
        else:
            return False

    def __str__(self):
        return 'Network {} (net: {}, port: {})'.format(
                                                       self.name,
                                                       self.network_ip,
                                                       self.port
                                                       )

    def __repr__(self):
        return "Network('{}', '{}', {})".format(
                                                self.name,
                                                self.network_ip,
                                                self.port
                                                )


class Queue(Network):
    """
    A Queue represent a partition of the cluster identified by a particular
    network among the nodes

    Args:
        - name (str): the name of the queue
        - network (str): the subnet of the network (like '192.168.0.0'). It is
          assumed that the netmask is 255.255.255.0
        - port (int): the port where the openvpn server will listen for client
          connections
        - job_submitter_ip: the ip in the static network of the job submitter
          service associated to this queue
    """
    def __init__(self, name, network, port, job_submitter,
                 worker_template=None):
        name = name.lower().replace(' ', '-').replace('_', '-')
        super(Queue, self).__init__(name, network, port)
        self.job_submitter = job_submitter
        self.worker_template = worker_template

    def __str__(self):
        return 'Queue {} (net: {}, port: {})'.format(
                                                self.name,
                                                self.network_ip,
                                                self.port
                                                )

    def __repr__(self):
        return "Queue('{}', {}, {}, {})"\
               "".format(self.name, repr(self.network_ip), self.port,
                         repr(self.job_submitter))


class StaticNetwork(Network):
    """
    A network that hosts services with a fixed IP

    Args:
        - name (str): the name of the queue
        - network (str): the subnet of the network (like '192.168.0.0'). It is
          assumed that the netmask is 255.255.255.0
        - port (int): the port where the openvpn server will listen for client
          connections
        - services (dict): A dictionary that associates to each service its IP
    """
    def __init__(self, network, port):
        super(StaticNetwork, self).__init__('static', network, port)
        self.services = []

    def add_service(self, service):
        if service.ip not in self:
            raise ValueError('Ip {} for the {} static service is not inside '
                             'the static network subnet ({})'
                             .format(service.ip, service.name, self.network_ip))

        if service.ip == self.server_address:
            raise IpConflict('The ip {} is reserved for the vpn server (the '
                             'linker). It can not be used for the {} service'
                             ''.format(self.server_address, service.name))

        for svc in self.services:
            if svc.ip == service.ip:
                raise IpConflict('Conflict on ip {}: it can not be assigned to '
                                 'two different services ({} and {})'
                                 ''.format(svc.ip, svc.name, service.name))

        self.services.append(service)


class Host(object):
    """
    A Host represents a physical host where the docker-engine is running.
    This kind of objects are initialized using a dictionary of options
    (strings) like:
        - *name*" the name of the remote host
        - *type*: "local" if the docker daemon is running on the same machine
          which is running this script and its socket is /var/run/docker.sock
          (this is default configuration for docker) or "remote" if the docker
          daemon is running on a different machine and must be reached using a
          network connection. This parameter is mandatory!
        - *runs linker*: it can be "True" or "False". If it is True, the host
          will run the linker docker. Only one machine can set this parameter
          to True because only one linker is allowed. Moreover, because having
          a linker is essential for the infrastructure, at least one machine
          shall have this flag set to True. If it is not specified, it is
          assumed that it is "False".
        - *builds images*: it can be "True" or "False". The host that has
          a True flag here will build all the images. This host must be the
          same host where all the files of this script are saved. Therefore,
          usually this is the "local" machine (but this could be not the case
          if you have a shared filesystem among all the hosts). Of course, at
          least one host shall take care of creating the image. Moreover, no
          more than one host can build the image in the current implementation
          so this flag must be set to True for just one and only one machine.
          If it is not specified, it is assumed to be "False".
        - *ip*: the ip of the machine. This parameter is necessary only if:
              * the host type is "remote"
              * the host will run the linker
          If the host is remote, this IP is the one that will be used to reach
          docker-engine by this script.
          If the host will run the linker, this is the IP that all the other
          dockers will use to reach the linker.
          If the host is remote and it will run the linker, it will be used for
          both to reach the docker-engine and by all the others docker.
          Even if you are using just one host, never use 127.0.0.1 as IP for a
          host because the dockers will be never be able to reach it. Instead,
          use the ip of your docker network (or any other external IP).
        - *port*: the port that docker engine uses on the remote host. It has
          a meaning only if the type is "remote" (it can be omitted otherwise)
        - *tls authentication*: If the type of the machine is "remote", this
          flag set if the connection must use TLS or not. This flag must be set
          according to the options of the remote docker-engine. If the type is
          "remote", this flag is mandatory.

    Args:
        - *host_dict* (dict): a dictionary with all the options
        - *tls_auth* (optional): an TLSConfig object from the library docker
          to use if the machine uses the TLS authentication (by default is
          None)
    """
    def __init__(self, host_dict, tls_auth=None):
        # Read the name of the host
        self.name = host_dict['name']

        # Read the type fo the host (which is mandatory)
        if 'type' not in host_dict:
            raise ValueError('type field not specified for host {}'
                             ''.format(self.name))

        if host_dict['type'].lower() not in ('local', 'remote'):
            raise ValueError('type of host {} must be local or remote, not {}'
                             ''.format(self.name, host_dict['type']))

        self.type = host_dict['type'].lower()

        # If the machine is remote, read the port
        if self.type == 'remote':
            if 'port' not in host_dict:
                raise ValueError('"port" field not specified for the remote '
                                 'host {}'.format(self.name))
            try:
                port = int(host_dict['port'])
            except:
                raise ValueError('{} is not a valid integer for the port of '
                                 'the docker engine of the host {}'
                                 ''.format(host_dict['port'], self.name))
            if port < 1 or port > 65535:
                raise ValueError('{} is not a valid integer for the port of '
                                 'the docker engine of the host {}'
                                 ''.format(port, self.name))
            self.port = port

        # Read if the host must run the linker
        if 'runs linker' not in host_dict:
            self.runs_linker = False
        else:
            runs_linker_value = host_dict['runs linker'].lower()
            if runs_linker_value not in ('true', 'false'):
                raise ValueError('The only allowed values for the field '
                                 '"runs linker" are "true" and "false". '
                                 'Host {} tried to use "{}"'
                                 ''.format(self.name, runs_linker_value))
            if runs_linker_value == 'true':
                self.runs_linker = True
            else:
                self.runs_linker = False

        # Read if the host must build the images
        if 'builds images' not in host_dict:
            self.builds_images = False
        else:
            builds_images_value = host_dict['builds images'].lower()
            if builds_images_value not in ('true', 'false'):
                raise ValueError('The only allowed values for the field '
                                 '"builds images" are "true" and "false". '
                                 'Host {} tried to use "{}"'
                                 ''.format(self.name, builds_images_value))
            if builds_images_value == 'true':
                self.builds_images = True
            else:
                self.builds_images = False

        # Read the IP (if needed)
        self.ip = None
        if self.type == 'remote' or self.runs_linker is True:
            if 'ip' not in host_dict:
                raise ValueError('Ip not specified for the host {}. The "ip" '
                                 'field is mandatory for the remote hosts and '
                                 'for the host that runs the linker'
                                 ''.format(self.name))
        if 'ip' in host_dict:
            try:
                self.ip = IP(host_dict['ip'])
            except InvalidIP:
                raise ValueError('Malformed ip for the host {}'
                                 ''.format(self.name))

        # Read the TLS flag
        self.use_tls = None
        if self.type == 'remote':
            if 'tls authentication' not in host_dict:
                raise ValueError('"tls authentication" flag is missing in {} '
                                 'host. This flag is mandatory for the '
                                 'remote machines'.format(self.name))
            use_tls = host_dict['tls authentication'].lower()
            if use_tls not in ('true', 'false'):
                raise ValueError('The only allowed values for the field '
                                 '"tls authentication" are "true" and '
                                 '"false". Host {} tried to use "{}"'
                                 ''.format(self.name, use_tls))
            if use_tls == 'true':
                self.use_tls = True
            else:
                self.use_tls = False

        self.tls_auth = tls_auth
        if self.use_tls and self.tls_auth is None:
            raise ValueError('Host {} requires TLS authentication but "TLS '
                             'AUTHENTICATION" section is missing in general '
                             'configuration file or one of the fields "ca '
                             'cert", "client cert" or "client key" is not '
                             'present'.format(self.name))

    def __repr__(self):
        return '{}'.format(self.name)

    def get_docker_client(self):
        """
        Return a Docker command line for this host
        """
        if self.type == 'local':
            return Client(
                          base_url='unix://var/run/docker.sock',
                          version='auto'
                          )
        if self.use_tls:
            return Client(
                          base_url='https://{}:{}'.format(self.ip, self.port),
                          version='auto',
                          tls=self.tls_auth
                          )
        else:
            return Client(
                          base_url='http://{}:{}'.format(self.ip, self.port),
                          version='auto'
                          )

    def __str__(self):
        return "Host {} ({})".format(self.name, self.type)


class Config(object):
    """
    The configuration of the entire system. At the beginning, an object
    of this class contains no information (all attributes are "None").
    With the "read_from_dir" method, the attributes will change according to the
    content of files saved inside the the config_dir directory.

    Only one config object can exist at the same time. If there is an attempt
    to build another object of the class Config, the previous one will be
    returned instead
    """

    # This list is empty if no Config object has been created. Otherwise, it
    # stores the created Config object
    _configurations = []

    def __new__(cls):
        if len(Config._configurations) > 1:
            return Config._configurations[-1]
        return super(Config, cls).__new__(cls)

    def __init__(self):
        self._config_dir = None
        self.project = None
        self.template_dir = None
        self.user_template_dir = None
        self.keys_dir = None
        self.scratch_dir = None
        self.log_file = None
        self.log_verbosity = None
        self.static_network = None
        self.keys = None
        self.hosts = None
        self.tls_auth = None
        self.queues = None
        self.image_builder = None
        self.linker_ip = None
        self.running_linker_host = None
        self.base_image_is_a_template = None
        self.base_image_name = None

    def read_from_dir(self, config_dir, base_dir=''):
        # Read the general.cfg file
        self._config_dir = config_dir
        general_config_file = path.join(self._config_dir, 'general.cfg')
        general_config = ConfigParser()
        general_config.read(general_config_file)

        # Read the project name
        project_name = general_config.get('PROJECT', 'project name').lower()
        if re.match(PROJECT_NAME_MASK, project_name) is None:
            raise InvalidProjectName('A valid project name must match the '
                                     'following regular expression: {}'
                                     ''.format(PROJECT_NAME_MASK))
        self.project = project_name

        # Save the values of the directories
        template_dir = general_config.get('DIRECTORIES', 'system templates')
        user_template_dir = general_config.get('DIRECTORIES', 'user templates')
        keys_dir = general_config.get('DIRECTORIES', 'keys')
        scratch_dir = general_config.get('DIRECTORIES', 'scratch')

        self.template_dir = template_dir.replace('$BASEDIR', base_dir)
        self.user_template_dir = user_template_dir.replace('$BASEDIR', base_dir)
        self.keys_dir = keys_dir.replace('$BASEDIR', base_dir)
        self.scratch_dir = scratch_dir.replace('$BASEDIR', base_dir)

        # Read the values of the base image
        base_image_type = general_config.get('BASE IMAGE', 'type')
        if base_image_type.lower() not in ('template', 'image'):
            raise ValueError('The only valid values for the field "type" in '
                             'the "BASE IMAGE" section are "image" and '
                             '"template", not {}'.format(base_image_type))
        if base_image_type == 'template':
            self.base_image_is_a_template = True
        else:
            self.base_image_is_a_template = False
        self.base_image_name = general_config.get('BASE IMAGE', 'name')

        # Save the values for the logging system
        log_file = general_config.get('LOGGER', 'file')
        self.log_file = log_file.replace('$BASEDIR', base_dir)
        self.log_verbosity = general_config.get('LOGGER', 'verbosity')
        if self.log_verbosity not in ('debug', 'info', 'warning'):
            raise ValueError('{} is not a valid verbosity level for the '
                             'logger. Choose among debug, info and warning'
                             ''.format(self.log_verbosity))

        # Save the values for the static network
        static_network = general_config.get('STATIC NETWORK', 'network')
        static_network_port = general_config.get('STATIC NETWORK', 'port')
        self.static_network = StaticNetwork(
                                            static_network,
                                            static_network_port
                                            )
        slurm_m_ip = general_config.get('STATIC NETWORK', 'slurm_master_ip')
        slurm_master = StaticService('slurm_master',
                                     slurm_m_ip,
                                     system_template='slurm_master',
                                     user_template=None,
                                     user_defined=False)
        self.static_network.add_service(slurm_master)

        # Read the TLS authentication section in the general_config_file
        # We will use the fields of that section to create a TLSConfig
        # object. If the section is missing or the fields are empty, then
        # the object is None.
        if 'TLS AUTHENTICATION' not in general_config:
            self.tls_auth = None
        else:
            if 'ca cert' not in general_config['TLS AUTHENTICATION']:
                self.tls_auth = None
            elif 'client cert' not in general_config['TLS AUTHENTICATION']:
                self.tls_auth = None
            elif 'client key' not in general_config['TLS AUTHENTICATION']:
                self.tls_auth = None
            else:
                ca_cert = general_config.get('TLS AUTHENTICATION',
                                             'ca cert')
                client_cert = general_config.get('TLS AUTHENTICATION',
                                                 'client cert')
                client_key = general_config.get('TLS AUTHENTICATION',
                                                'client key')
                if client_key == '' or client_cert == '' or ca_cert == '':
                    self.tls_auth = None
                else:
                    client_cert_and_key = (client_cert, client_key)
                    self.tls_auth = TLSConfig(
                                              verify=ca_cert,
                                              client_cert=client_cert_and_key
                                              )

        # Read the configuration file for the keys
        key_file = path.join(self._config_dir, 'keys.cfg')
        key_config = ConfigParser()
        key_config.read(key_file)
        self.keys = key_config

        # Read the configuration files for the queues
        queue_file = path.join(self._config_dir, 'queues.cfg')
        queue_config = ConfigParser()
        queue_config.read(queue_file)
        self.queues = []
        for queue_name in queue_config.sections():
            queue_network = queue_config.get(queue_name, 'network')
            queue_port = int(queue_config.get(queue_name, 'port'))
            job_submitter_ip = queue_config.get(queue_name, 'job submitter ip')
            job_sub_uses_template = queue_config.get(
                queue_name,
                'job submitter uses a template'
            )
            if job_sub_uses_template.lower() not in ('true', 'false'):
                raise ValueError('The field "job submitter uses a template" in '
                                 'the "{}" section of the queues.cfg file must'
                                 'be "True" or "False", not {}'
                                 .format(queue_name, job_sub_uses_template))
            if job_sub_uses_template.lower() == 'true':
                job_submitter_template = queue_config.get(
                    queue_name,
                    'job submitter template'
                )
            else:
                job_submitter_template = None
            job_submitter_service = StaticService(
                '{}_job_submitter'.format(queue_name),
                job_submitter_ip,
                system_template='job_submitter',
                user_template=job_submitter_template,
                user_defined=False
            )
            worker_uses_template = queue_config.get(
                queue_name,
                'worker uses a template'
            )
            if worker_uses_template.lower() not in ('true', 'false'):
                raise ValueError('The field "worker uses a template" in '
                                 'the "{}" section of the queues.cfg file must'
                                 'be "True" or "False", not {}'
                                 .format(queue_name, worker_uses_template))
            if worker_uses_template.lower() == 'true':
                worker_template = queue_config.get(
                    queue_name,
                    'worker template'
                )
            else:
                worker_template = None
            queue = Queue(queue_name, queue_network, queue_port,
                          job_submitter_service, worker_template)
            self.static_network.add_service(job_submitter_service)
            self.queues.append(queue)

        # Read the configuration files for the hosts
        host_file = path.join(self._config_dir, 'hosts.cfg')
        host_config = ConfigParser()
        host_config.read(host_file)
        self.hosts = []
        for host_name in host_config.sections():
            host_dict = dict()
            host_dict['name'] = host_name.lower()
            for host_field, host_value in host_config[host_name].items():
                host_dict[host_field.lower()] = host_value
            self.hosts.append(Host(host_dict, self.tls_auth))

        # Check if there is exactly one machine that builds the images
        builds_images_hosts = [h for h in self.hosts if h.builds_images]
        if len(builds_images_hosts) == 0:
            raise ValueError('No host with the "builds images" set to "true" '
                             'found in the host.cfg file')
        if len(builds_images_hosts) > 1:
            bi = ', '.join(h.name for h in builds_images_hosts)
            raise ValueError('Only one host can build the images, but there '
                             'are several ones with the "builds_images" flag '
                             'set to "true": ' + str(bi))

        # Save the host that will build the images
        self.image_builder = builds_images_hosts[0]

        # Check if there is exactly one machine that runs the linker
        running_linker_hosts = [h for h in self.hosts if h.runs_linker]
        if len(running_linker_hosts) == 0:
            raise ValueError('No host with the "runs linker" set to "true" '
                             'found in the host.cfg file')
        if len(running_linker_hosts) > 1:
            rt = ', '.join(h.name for h in running_linker_hosts)
            raise ValueError('Only one host can run the linker, but there '
                             'are several ones with the "runs linker" flag '
                             'set to "true": ' + str(rt))

        # Save the host that will run the linker
        self.running_linker_host = running_linker_hosts[0]

        # Set the external IP of the linker
        self.linker_ip = self.running_linker_host.ip

        # Read the configuration file for the static services
        st_services_file = path.join(self._config_dir, 'static_services.cfg')
        st_services_config = ConfigParser()
        st_services_config.read(st_services_file)
        for service_name in st_services_config.sections():
            service_ip = st_services_config.get(service_name, 'ip')
            service_template = st_services_config.get(service_name, 'template')
            service = StaticService(service_name, service_ip, service_template)
            self.static_network.add_service(service)

        # Add the current object to the _conifguration list
        Config._configurations.append(self)


config = Config()
